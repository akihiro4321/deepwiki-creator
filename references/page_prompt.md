# ページコンテンツ 生成ガイドライン

## 最重要ルール

**ファイルの中身を読む前にページを書き始めてはならない。**
relevant_files のコードを実際に読み、export の実装を理解してから書く。

## 品質の3層構造

各記述は以下の3層を意識する。「What」だけで終わるページは品質不足：

1. **What（何をするか）**: そのコンポーネントの責務と機能
2. **How（どうやるか）**: 具体的な実装メカニズム、アルゴリズム、データの流れ
3. **Why（なぜそうするか）**: その設計を選んだ理由、トレードオフ、代替案との比較

## 必須要件

### Comprehensiveモード

各ページは以下を **全て** 含むこと：

- [ ] **60行以上** のコンテンツ
- [ ] **コードスニペット**: 最低1つ、最大3つ（言語タグ付き、5〜10行）
- [ ] **Mermaid図**: 最低1つ（矢印にデータの中身を記載）
- [ ] **メソッドシグネチャ**: primary_exports の主要メソッド
- [ ] **異常系の記述**: エラーハンドリング、フォールバック、バリデーション失敗時
- [ ] **設計判断**: なぜその方式を選んだかの説明（最低1つ）

## ページ構成テンプレート（Comprehensiveモード - 通常ページ）

**以下の見出しは全て必須。** 見出しが1つでも欠けているページは不合格とする。
テンプレートに沿わないページは validate_wiki.sh で検出され、再生成が必要になる。

```markdown
# {page.title}

{概要: 2〜3文。**何を解決し**、システム全体の **どこに位置するか**。
primary_exports を名前付きで紹介}

## アーキテクチャ

{設計パターン、レイヤー構造、主要な設計判断}

```mermaid
{コンポーネント構成図。矢印にデータの内容を記載}
```

## 主要コンポーネント

### {Class/Function名}

**責務**: {1文}

**主要メソッド:**
- `methodName(param: Type): ReturnType` - {1行説明}

**実装のポイント:**
{条件分岐、エラーハンドリング、パフォーマンス上の工夫}

```{language}
// {1行説明}
{重要部分 5〜10行}
```

## 設計判断

{このモジュールの設計で行われた重要な判断を記述する:
 - なぜこのパターン/アーキテクチャを選んだか
 - 何とのトレードオフがあるか
 - この設計により何が可能/不可能になるか

例: 「定義と実行を分離するDeclarative Tool Patternを採用している。
これにより、ツールの実行前にDryRunやユーザー確認を挟む制御が、
個々のツール実装を変更せずに実現できる。一方、単純なツールでも
Definition + Invocationの2クラスが必要になるオーバーヘッドがある。」}

## エラーハンドリングと境界条件

{具体的なエラーパターンとリカバリー戦略:
 - どのようなエラーが発生しうるか
 - リトライ、フォールバック、ユーザー通知
 - タイムアウト、リソース制限}

## データフロー

{入力 → 処理 → 出力。正常系と異常系}

```mermaid
sequenceDiagram
{矢印にデータ型/内容を記載。alt/optで分岐を表現}
```

## 関連ページ

- [{related_page.title}](../section-dir/page-file.md) - {関係性1文}

---
*生成元: `file1.ts`, `file2.ts`*
```

### 必須見出しチェックリスト（通常ページ）

ページ書き出し後、以下の見出しが **全て** 存在することを確認する：

- [ ] `# {page.title}` — タイトルと概要
- [ ] `## アーキテクチャ` — 設計パターンとMermaid図（1つ以上）
- [ ] `## 主要コンポーネント` — クラス/関数の責務、メソッドシグネチャ、コードスニペット（1つ以上）
- [ ] `## 設計判断` — Whyの記述（1つ以上）
- [ ] `## エラーハンドリングと境界条件` — 異常系の記述
- [ ] `## データフロー` — 入力→処理→出力とMermaid図
- [ ] `## 関連ページ` — 関連ページへのリンク
- [ ] `*生成元: ...*` — 末尾の生成元ファイル一覧

**見出しが欠けている場合**: 該当セクションを追記してから書き出すこと。
「該当なし」の場合でも見出しを残し、簡潔にその旨を記載する。

## ページ構成テンプレート（Comprehensiveモード - エンドツーエンドフロー）

```markdown
# {title: 例「リクエストライフサイクル」}

{概要: このページはモジュール横断の処理フローを追う。
ユーザーの入力から最終出力まで、どのコンポーネントがどう連携するかを解説する}

## 全体フロー

```mermaid
sequenceDiagram
    participant User
    participant CLI
    participant Core
    participant API
    participant Tools

    User ->>+ CLI: プロンプト入力
    CLI ->>+ Core: sendMessageStream(input)
    Core ->>+ API: generateContentStream(context + prompt)
    
    alt テキスト応答
        API -->>- Core: StreamChunk(TextDelta)
        Core -->> CLI: GeminiEvent(Content)
        CLI -->> User: テキスト表示
    else ツール呼び出し
        API -->>- Core: StreamChunk(FunctionCall)
        Core ->> Core: Scheduler.schedule(toolCalls)
        Core ->> CLI: ConfirmationRequest
        CLI ->> User: 確認ダイアログ
        User -->> CLI: 承認
        CLI -->> Core: Approved
        Core ->>+ Tools: execute(params)
        Tools -->>- Core: ToolResult
        Core ->>+ API: generateContentStream(toolResult)
        API -->>- Core: StreamChunk(TextDelta)
        Core -->> CLI: GeminiEvent(Content)
        CLI -->> User: 最終回答表示
    end
```

## Step 1: ユーザー入力の受け取り
{CLIレイヤーでの処理。どのファイル/関数が入力を受け取り、何に変換するか}

## Step 2: API通信
{コアレイヤーでの処理。リクエストの構築、コンテキストの付与、ストリーミング}

## Step 3: ツール実行（発生する場合）
{スケジューラ → ポリシーチェック → 確認 → 実行 → 結果送信}

## Step 4: 応答の表示
{ストリーミングイベントの処理、UI更新}

## エラーケース
{各ステップで起こりうるエラーと、そのリカバリーフロー}

---
*生成元: {横断的なファイルパス一覧}*
```

### Conciseモード

各ページは以下を含むこと：

- [ ] **30行以上** のコンテンツ
- [ ] **Mermaid図**: 最低1つ（矢印にデータの中身を記載）
- [ ] **主要コンポーネントの説明**: 各2〜3文

## ページ構成テンプレート（Conciseモード）

```markdown
# {page.title}

{概要: 2〜3文}

## 構成

```mermaid
{アーキテクチャ図}
```

{主要コンポーネントの説明。各2〜3文}

## 関連ページ

- [{related_page.title}](../section-dir/page-file.md)

---
*生成元: `file1.ts`, `file2.ts`*
```

## Mermaid図の品質基準

- 1ページに1〜3つが適切
- **矢印のラベルにデータの中身を書く（必須）**
  - 良い: `A ->>|"sendMessageStream(input)"| B`
  - 悪い: `A ->> B`
- **条件分岐（alt/opt）を活用する**
  - 正常系だけでなく、エラー時・分岐時のフローも含める
- ノード/participant にはコード上のクラス名・関数名を使う

## コードスニペットの品質基準

- 5〜10行が最適。15行以上は長すぎる
- **抽象的な型定義より、実際の処理ロジックを優先する**
  - 良い: エラーハンドリング、状態遷移、ビジネスロジック
  - 悪い: 空のインターフェース、型エイリアスだけ

## 設計判断の記述基準

以下のうち少なくとも1つに触れること：
- **パターン選択の理由**: なぜこのデザインパターンを使うのか
- **トレードオフ**: この設計で得られるものと失うもの
- **代替案**: 別の方式と比較してなぜこちらを選んだか
- **制約起因の設計**: APIの制限やパフォーマンス要件から生まれた設計

## 異常系記述の基準

以下のいずれかに該当する記述を含めること：
- try-catch / Result 型 / error return によるエラー処理の方針
- バリデーション失敗時の挙動
- タイムアウト、リトライ回数、バックオフ戦略
- リソース不足・ファイル不在・ネットワーク障害時のフォールバック

## ページ間の一貫性

- **`_consistency_guide.md` に従う**
- 同じクラス/関数を複数ページで説明しない
- 他ページの担当コンポーネントは「詳細は [ページ名](リンク) を参照」
- 用語は一貫性ガイドの用語辞書に従う
